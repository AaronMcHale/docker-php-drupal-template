#!/usr/bin/env sh
# Script to execute composer inside a Docker container
#
# The following environment variables can be set to override specific values:
# - COMPOSER_HOME
# See comments below for documentation on how these work.

# Exit this script if any exit with a non-zero state
set -e

# Ensure we are in the project root directory. This still allows the script
# to work even if we call it from a different directory in or out of the
# project.
cd "${0%/*}"

## Export keys and values defined in the `.env` file.
if [ -f ".env" ]; then
  # Source the .env file but ignore comments
  export $(grep -v '^#' .env | xargs)
fi

# We'll append all of the arguments that we'll pass to `docker run` in this
# `docker_args` variable. Start by telling Docker to remove it from the list
# once we're done with it.
docker_args="--rm"

# Mount the Composer Home from the host system into the container, this way the
# container can write to a central cache which persists and can be reused across
# different projects. Use the `$COMPOSER_HOME` environment variable or default to
# `$HOME/.composer` if not set.
COMPOSER_HOME=${COMPOSER_HOME:-$HOME/.composer}
if [ ! -d "$COMPOSER_HOME" ]; then
  mkdir "$COMPOSER_HOME"
fi
docker_args="$docker_args --volume $COMPOSER_HOME:/home/composer"
echo "Mounting $COMPOSER_HOME for cache."

# Get the user and group IDs of the current user, we then pass these to the Docker
# Container, which runs using these, thus when Composer running inside the container
# writes to the filesystem it uses the same user and group IDs as the current user.
# This is important on a development environment, where we don't want file permission
# conflicts to start occurring, and since Composer would usually only be run in
# the development environment, this is the most optimal behaviour.
user_id=$(id -u)
group_id=$(id -g)
docker_args="$docker_args --user=$user_id:$group_id"

# Run the Docker container, passing in the various arguments we defined above.
# `$*` allows us to pass in all of the parameters that were passed to this script,
# this way we can just forward them onto the Composer command.
command="$*"
if [ -z "$command" ]; then
  command="composer"
fi

./docker-compose run $docker_args --entrypoint /usr/local/bin/composer-entrypoint.sh drupal-cli $command
