#!/usr/bin/env sh
# Script to execute composer inside a Docker container

# Ensure we are in the project root directory. This still allows the script
# to work even if we call it from a different directory in or out of the
# project.
cd "${0%/*}"

# Get the directory name of this directory, use that as the project name.
project_name="${PWD##*/}"

# We'll append all of the arguments that we'll pass to `docker run` in this
# `docker_args` variable. Start by telling Docker to remove it from the list
# once we're done with it.
docker_args="--rm"

# We need the user to be able to fully interact with Composer running in the container
# - Tell docker to take over Standard In, Out and Error
# - Run in interactive mode
# - Attach to the active terminal
# - Proxy any signals to Composer, e.g. if the user terminates the process
docker_args="$docker_args --attach STDIN --attach STDOUT --attach STDERR --interactive --tty --sig-proxy=true"

# Mount rootfs as read-only to help ensure the integrity of the container.
docker_args="$docker_args --read-only"

# Mount the Composer Home from the host system into the container, this way the
# container can write to a central cache which persists and can be reused across
# different projects. Use the `$COMPOSER_HOME` environment variable or default to
# `$HOME/.composer` if not set.
COMPOSER_HOME=${COMPOSER_HOME:-$HOME/.composer}
docker_args="$docker_args --volume $COMPOSER_HOME:/tmp"
echo "Mounting $COMPOSER_HOME for cache."
# Alternatively, a temp filesystem can be used, however this doesn't persist.
#docker_args="$docker_args --tmpfs /tmp"

# Mount the `app` directory as a volume and set the working directory to this path
# We use the `$COMPOSER_APP_DIR` environment variable (which is not a Composer thing)
# as our Docker test script uses this.
COMPOSER_APP_DIR=${COMPOSER_APP_DIR:-$PWD/app}
docker_args="$docker_args --volume $COMPOSER_APP_DIR:/app --workdir=/app"

# Get the user and group IDs of the current user, we then pass these to the Docker
# Container, which runs using these, thus when Composer running inside the container
# writes to the filesystem it uses the same user and group IDs as the current user.
# This is important on a development environment, where we don't want file permission
# conflicts to start occurring, and since Composer would usually only be run in
# the development environment, this is the most optimal behaviour.
user_id=$(id -u)
group_id=$(id -g)
docker_args="$docker_args --user=$user_id:$group_id"

# Run the Docker container, use the image which must be built when running
# `./docker-build`, and passing in the various arguments we defined above.
# `$*` allows us to pass in all of the parameters that were passed to this script,
# this way we can just forward them onto the Composer command.
COMPOSER_CONTAINER_NAME=${COMPOSER_CONTAINER_NAME:-"${project_name}_composer"}
docker run $docker_args "$COMPOSER_CONTAINER_NAME" $*
